#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{bbold}
\usepackage{tikz}
\tikzstyle{every picture}+=[remember picture]
\usetikzlibrary{decorations.pathmorphing}
\tikzset { domaine/.style 2 args={domain=#1:#2} }
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language french
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\nraf}{\text{{nraf}}}
{\mathrm{nraf}}
\end_inset


\end_layout

\begin_layout Title
SCHNAPS: Solveur Conservatif Hyperbolique Non-linéaire Appliqué aux PlaSmas
\end_layout

\begin_layout Author
IRMA Strasbourg
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Dans ce chapitre, nous rappelons d'abord rapidement le formalisme de la
 méthode Galerkin Discontinu (GD).
 Cette méthode est très générale puisqu'elle autorise des maillages non-conforme
s ainsi que des degrés d'approximation non-uniforme.
 Cependant sa programmation dans un cadre trop général risque d'être inefficace
 sur un ordinateur hybride possédant plusieurs niveaux de mémoires et de
 parallélisme: les indirections mémoire, les trop grandes variations de
 paramètres, un rangement arbitraire des données en mémoire peuvent conduire
 à des performances désastreuses.
 Nous allons donc présenter ici les choix que nous avons fait afin d'obtenir
 un bon compromis entre la généralité de la méthode et son efficacité.
 Le résultat de ces compromis est le logiciel SCHNAPS développé depuis deux
 à l'IRMA Strasbourg.
\end_layout

\begin_layout Standard
SCHNAPS est un acronyme de 
\begin_inset Quotes eld
\end_inset

Solveur Conservatif Hyperbolique Non-linéaire Appliqué aux PlasmaS
\begin_inset Quotes erd
\end_inset

.
 Il s'agit d'une bibliothèque C99 pour résoudre numériquement des systèmes
 de lois de conservation sur des ordinateurs massivement parallèles, avec
 plusieurs niveaux de parallélisme, par exemple un gros cluster comprenant
 à la fois des CPU et des GPU.
\end_layout

\begin_layout Section
Méthode Galerkin Discontinu (GD)
\end_layout

\begin_layout Subsection
Systèmes de lois de conservation
\end_layout

\begin_layout Standard
SCHNAPS se veut assez général.
 Par conséquent, nous considérons un domaine ouvert borné 
\begin_inset Formula $\Omega\subset\mathbb{R}^{3}$
\end_inset

 de frontière 
\begin_inset Formula $\partial\Omega$
\end_inset

.
 Sur ce domaine, nous considérons un système de lois de conservation de
 la forme
\begin_inset Formula 
\begin{equation}
\partial_{t}W+\partial_{i}F^{i}(W)=S(W).\label{eq:slc}
\end{equation}

\end_inset

Dans cette équation, l'inconnue 
\begin_inset Formula $W(x,t)$
\end_inset

 est un vecteur de 
\begin_inset Formula $\mathbb{R}^{m}$
\end_inset

 qui dépend d'une variable d'espace 
\begin_inset Formula $x\in\Omega$
\end_inset

, 
\begin_inset Formula $transfertsx=(x_{1},x_{2},x_{3})$
\end_inset

 et du temps 
\begin_inset Formula $t\in[0,T]$
\end_inset

.
 Le vecteur 
\begin_inset Formula $S$
\end_inset

 représente les termes sources du système.
 Nous utilisons la convention de sommation sur les indices répétés.
 Soit un vecteur 
\begin_inset Formula $n=(n_{1},n_{2},n_{3})\in\mathbb{R}^{3}$
\end_inset

, nous définissons le flux du système (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:slc"

\end_inset

) par
\begin_inset Formula 
\begin{equation}
F(W,n)=F^{i}(W)n_{i}.\label{eq:flux}
\end{equation}

\end_inset

Il faut adjoindre des conditions aux limites à (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:slc"

\end_inset

).
 Formellement, ces conditions aux limites sont données par un flux frontière
 
\begin_inset Formula $F_{b}$
\end_inset

 et s'écrivent 
\begin_inset Formula 
\begin{equation}
F(W,n)=F_{b}(W,n),\quad x\in\partial\Omega,\label{eq:fluxbord}
\end{equation}

\end_inset

où 
\begin_inset Formula $n$
\end_inset

 désigne le vecteur normal sortant à 
\begin_inset Formula $\Omega$
\end_inset

 sur 
\begin_inset Formula $\partial\Omega$
\end_inset

.
 D'autre part, nous nous donnons aussi une condition initiale
\begin_inset Formula 
\[
W(x,0)=W_{0}(x),\quad x\in\Omega.
\]

\end_inset


\end_layout

\begin_layout Standard
SCHNAPS permet de résoudre ce problème d'évolution par la méthode de Galerkin
 Discontinu (GD).
 Comme son nom l'indique, cette méthode consiste à construire une approximation
 de la solution au moyen d'éléments finis discontinus.
\end_layout

\begin_layout Subsection
Flux numérique
\end_layout

\begin_layout Standard
La méthode GD est une généralisation de la méthode des éléments finis et
 de la méthode des volumes finis.
 Elle nécessite la définition d'un flux numérique sur les discontinuités
 de la solution discrète.
 Ce flux numérique est noté
\begin_inset Formula 
\begin{equation}
F(W_{L},W_{R},n_{LR}),\label{eq:fluxnum}
\end{equation}

\end_inset

où 
\begin_inset Formula $W_{L}$
\end_inset

 et 
\begin_inset Formula $W_{R}$
\end_inset

 représentent les valeurs de 
\begin_inset Formula $W$
\end_inset

 de part et d'autre de la discontinuité, et 
\begin_inset Formula $n_{LR}$
\end_inset

 un vecteur normal à la discontinuité orienté du côté 
\begin_inset Formula $L$
\end_inset

 vers le côté 
\begin_inset Formula $R$
\end_inset

.
 Cette notation, bien que légèrement abusive, ne peut pas être confondue
 avec celle du flux (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:flux"

\end_inset

), car le flux numérique dépend de deux états, 
\begin_inset Formula $W_{L}$
\end_inset

 et 
\begin_inset Formula $W_{R}$
\end_inset

, au lieu d'un seul.
 Pour que l'approximation GD soit consistante avec le système (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:slc"

\end_inset

), il faut que
\begin_inset Formula 
\begin{equation}
\forall W,n,\quad F(W,W,n)=F(W,n).\label{eq:consistance}
\end{equation}

\end_inset

Souvent, le flux numérique vérifie aussi une propriété de conservationtransferts
\begin_inset Formula 
\begin{equation}
\forall W_{L},W_{R},n,\quad F(W_{L},W_{R},n)=-F(W_{R},W_{L},-n),\label{eq:consflux}
\end{equation}

\end_inset

mais ce n'est pas toujours le cas, et ce n'est pas une nécessité dans SCHNAPS.
\end_layout

\begin_layout Standard
À partir de la fonction flux, nous pouvons retrouver les composantes du
 flux.
 Nous introduisons le symbole de Kronecker
\begin_inset Formula 
\[
\delta_{i}^{j}=\left\{ \begin{array}{ccc}
1 & \text{if} & i=j,\\
0 & \text{if} & i\neq j.
\end{array}\right.
\]

\end_inset

Le vecteur 
\begin_inset Formula $\delta^{j}$
\end_inset

 est un vecteur unitaire de 
\begin_inset Formula $\mathbb{R}^{3}$
\end_inset

 qui pointe dans la direction 
\begin_inset Formula $x_{j}$
\end_inset

.
 Alors
\begin_inset Formula 
\begin{equation}
F^{j}(W)=F(W,\delta^{j}).\label{eq:flux2comp}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Par exemple, les équations de Maxwell entrent dans ce formalisme.
 Elles s'écrivent
\begin_inset Formula 
\begin{eqnarray}
\partial_{t}E-\nabla\times H & = & -J,\label{eq:ampere}\\
\partial_{t}H+\nabla\times E & = & 0,\label{eq:faraday}
\end{eqnarray}

\end_inset

où 
\begin_inset Formula $E$
\end_inset

 est le champ électrique, 
\begin_inset Formula $H$
\end_inset

 le champ magnétique et 
\begin_inset Formula $J$
\end_inset

 le vecteur courant électrique.
 Nous posons
\begin_inset Formula 
\[
W=(E^{T},H^{T})^{T},\quad S=(-J^{T},(0,0,0)^{T})^{T},
\]

\end_inset

et
\begin_inset Formula 
\[
F(W,n)=\left[\begin{array}{cc}
0 & n\times\\
-n\times & 0
\end{array}\right]W=A(n)W,
\]

\end_inset

de telle façon que les équations de Maxwell sont un cas particulier de (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:slc"

\end_inset

), avec 
\begin_inset Formula $m=6$
\end_inset

.
\end_layout

\begin_layout Standard
Comme dans (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:flux2comp"

\end_inset

) nous pouvons définir les matrices symétriques 
\begin_inset Formula $6\times6$
\end_inset


\begin_inset Formula 
\[
A^{i}=A(\delta^{i}),\quad i=1\cdots3.
\]

\end_inset

Alors les équations de Maxwell peuvent aussi être écrites sous la forme
 d'un système hyperbolique, aussi appelé système de Friedrichs
\begin_inset Formula 
\[
\partial_{t}W+A^{i}\partial_{i}W=S.
\]

\end_inset


\end_layout

\begin_layout Subsection
Formalisme GD général
\end_layout

\begin_layout Standard
Pour définir l'approximation GD, nous devons d'abord construire un maillage
 de 
\begin_inset Formula $\Omega$
\end_inset

.
 Nous considérons un maillage constitué d'un nombre fini d'ensembles ouverts
 
\begin_inset Formula $L_{k}\subset\Omega$
\end_inset

, 
\begin_inset Formula $k=1\cdots N,$
\end_inset

 appelés 
\begin_inset Quotes eld
\end_inset

cellules
\begin_inset Quotes erd
\end_inset

 ou 
\begin_inset Quotes eld
\end_inset

éléments
\begin_inset Quotes erd
\end_inset

, et satisfaisant les deux conditions:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall k,l\quad k\neq l\Rightarrow L_{k}\cap L_{l}=\emptyset$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\overline{\cup_{k}L_{k}}=\overline{\Omega}.$
\end_inset


\end_layout

\begin_layout Standard
Soient 
\begin_inset Formula $L$
\end_inset

 et 
\begin_inset Formula $R$
\end_inset

 deux cellules voisines.
 La face commune à 
\begin_inset Formula $L$
\end_inset

 et 
\begin_inset Formula $R$
\end_inset

 est notée
\begin_inset Formula 
\[
L/R=\overline{L}\cap\overline{R}.
\]

\end_inset

Nous notons aussi 
\begin_inset Formula $n_{LR}$
\end_inset

 le vecteur normal unitaire sur 
\begin_inset Formula $L/R$
\end_inset

 orienté 
\begin_inset Formula $L$
\end_inset

 vers 
\begin_inset Formula $R$
\end_inset

.
 Donc, 
\begin_inset Formula $n_{LR}=-n_{RL}.$
\end_inset


\end_layout

\begin_layout Standard
Dans chaque cellule 
\begin_inset Formula $L$
\end_inset

, nous construisons une base de fonctions scalaires 
\begin_inset Formula $\varphi_{i}^{L}$
\end_inset

, 
\begin_inset Formula $i=1\cdots p_{L}$
\end_inset

 dont le support est dans 
\begin_inset Formula $L$
\end_inset

.
 Il est possible d'avoir des niveaux d'approximation différents 
\begin_inset Formula $p_{L}$
\end_inset

 sur des cellules différentes.
 Dans la cellule 
\begin_inset Formula $L$
\end_inset

, la solution de 
\begin_inset Formula $(\ref{eq:slc})$
\end_inset

 est approchée par
\begin_inset Formula 
\begin{equation}
W(X,t)=W_{L}(X,t)=W_{L}^{j}(t)\varphi_{j}^{L}(X)\quad X\in L.\label{eq:approx}
\end{equation}

\end_inset

La solution numérique satisfait le schéma d'approximation GD
\begin_inset Formula 
\begin{equation}
\forall L,\forall i\quad\int_{L}\partial_{t}W\varphi_{i}^{L}-\int_{L}F(W,\nabla\varphi_{i}^{L})+\int_{\partial L}F(W_{L},W_{R},n_{LR})\varphi_{i}^{L}=\int_{L}S\varphi_{i}^{L}.\label{eq:DG}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Pour plus de clarté, nous pouvons faire les remarques suivantes sur le schéma
 GD (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DG"

\end_inset

):
\end_layout

\begin_layout Enumerate
La formulation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DG"

\end_inset

) est obtenue formellement en multipliant (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:slc"

\end_inset

) par une fonction de base 
\begin_inset Formula $\varphi_{i}^{L}$
\end_inset

 et en intégrant par parties sur la cellule 
\begin_inset Formula $L$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Nous utilisons (de façon abusive) la même notation la solution exacte et
 la solution approchée.
 En général, à partir de maintenant 
\begin_inset Formula $W$
\end_inset

 désignera l'approximation GD de la solution exacte.
\end_layout

\begin_layout Enumerate
Par 
\begin_inset Formula $R$
\end_inset

 nous désignons une cellule générique qui touche la cellule 
\begin_inset Formula $L$
\end_inset

 le long de sa frontière 
\begin_inset Formula $\partial L$
\end_inset

.
 Cette notation est justifiée par le fait que, à une rotation près, on peut
 toujours supposer que le vecteur normal 
\begin_inset Formula $n_{LR}$
\end_inset

 est orienté de la cellule 
\begin_inset Formula $L$
\end_inset

 à gauche (Left), vers la cellule 
\begin_inset Formula $R$
\end_inset

 à droite (Right).
\end_layout

\begin_layout Enumerate
Comme 
\begin_inset Formula $W$
\end_inset

 est discontinu sur le bord de la cellule, il n'est pas possible de définir
 
\begin_inset Formula $F(W,n_{LR})$
\end_inset

 sur 
\begin_inset Formula $\partial L$
\end_inset

.
 Par conséquent, comme dans la méthode des volumes finis, nous devons utiliser
 un flux numérique 
\begin_inset Formula $F(W_{L},W_{R},n_{LR})$
\end_inset

, introduit dans la section précédente.
 Le flux numérique satisfait souvent les deux conditions
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Consistance: 
\begin_inset Formula $F(W,W,n)=F(W,n).$
\end_inset


\end_layout

\begin_layout Enumerate
Conservation: 
\begin_inset Formula $F(W_{L},W_{R},n_{LR})=-F(W_{R},W_{L},n_{RL}).$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Dans le cas des équations de Maxwell, nous utilisons le flux décentré standard
\begin_inset Formula 
\[
F(W_{L},W_{R},n)=A(n)^{+}W_{L}+A(n)^{-}W_{R}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
Finalement, dans (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DG"

\end_inset

) nous devons être plus précis lorsque la cellule 
\begin_inset Formula $L$
\end_inset

 touche le bord du domaine de calcul.
 En effet, sur 
\begin_inset Formula $\partial L\cap\Omega$
\end_inset

 le champ 
\begin_inset Formula $W_{R}$
\end_inset

 n'est pas disponible.
 Nous remplaçons donc sur ces interfaces le flux numérique 
\begin_inset Formula $F(W_{L},W_{R},n_{LR})$
\end_inset

 par le flux frontière
\begin_inset Formula 
\[
F_{b}(W_{L},n_{LR}).
\]

\end_inset


\end_layout

\begin_layout Standard
Nous pouvons alors introduire le développement (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:approx"

\end_inset

) dans (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DG"

\end_inset

).
 L'approximation GD devient alors un système d'équations différentielles
 ordinaires satisfaites par les coefficients 
\begin_inset Formula $W_{L}^{j}(t)$
\end_inset

 sur les bases locales.
 Nous résolvons ce système d'équations différentielles par un intégrateur
 Runge-Kutta du second ordre.
\end_layout

\begin_layout Section
SCHNAPS: philosophie
\end_layout

\begin_layout Standard
Dans cette section nous tentons de donner une vue d'ensemble synthétique
 de la conception du logiciel.
\end_layout

\begin_layout Subsection
StarPU
\end_layout

\begin_layout Standard
Afin d'exploiter les architectures d'ordinateurs hybrides les plus récentes,
 il est indispensable de pouvoir soumettre de façon asynchrone des opérations
 de calcul ou de transferts (copies mémoire ou communications).
 Ces opérations, appelées tâches (
\begin_inset Quotes eld
\end_inset

tasks
\begin_inset Quotes erd
\end_inset

 en anglais), dépendent en général les unes des autres.
 Ce sont les dépendances entre les tâches qui permettent de déterminer l'ordre
 dans lequel elle doivent être exécutées et si certaines d'entre elles peuvent
 être réalisées en parallèle.
\end_layout

\begin_layout Standard
Les dépendances entre tâches sont souvent représentée par un graphe.
 Les noeuds du graphe correspondent aux tâches.
 La présence d'un arc orienté de la tâche A vers la tâches B indique qu'il
 faut attendre la fin de A avant de lancer B.
 Voir Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Graphe-des-tâches"

\end_inset

.
 En général, la construction d'un graphe des tâches ne nécessite que la
 connaissance des dépendances entre les données.
 Il suffit d'indiquer sur quelles données chaque tâche va opérer et si ces
 données sont accédées en lecture (R), écriture (W) ou lecture/écriture
 (RW).
 Il existe une littérature plus qu'abondante sur ces techniques algorithmiques.
 Ce n'est pas l'objet de cette thèse de rentrer trop dans les détails.
 Nous renvoyons par exemple à 
\begin_inset CommandInset citation
LatexCommand cite
key "cosnard1995automatic,cosnard1999compact"

\end_inset

.
\end_layout

\begin_layout Standard
La programmation efficace et générale de ce type d'algorithme est compliquée
 
\begin_inset CommandInset citation
LatexCommand cite
key "strub2015resolution"

\end_inset

.
 Nous avons donc décidé de déléguer la répartition des tâches sur les processeur
s disponibles à une bibliothèque informatique spécialisée.
 Ce type de bibliothèque, aussi appelée 
\begin_inset Quotes eld
\end_inset

support d’exécution
\begin_inset Quotes erd
\end_inset

 ou 
\begin_inset Quotes eld
\end_inset

runtime
\begin_inset Quotes erd
\end_inset

 en anglais permet de décrire à la fois le code des tâches ainsi que le
 type d'accès aux données.
\end_layout

\begin_layout Standard
Nous avons choisi le support d’exécution StarPU 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://starpu.gforge.inria.fr/
\end_layout

\end_inset

.
 Il s'agit d'un logiciel développé depuis plus de 10 ans à l'Inria Bordeaux
 
\begin_inset CommandInset citation
LatexCommand cite
key "augonnet2011starpu"

\end_inset

.
 Au coeur de StarPU il y a les 
\begin_inset Quotes eld
\end_inset

codelettes
\begin_inset Quotes erd
\end_inset

 (ou 
\begin_inset Quotes eld
\end_inset

codelet
\begin_inset Quotes erd
\end_inset

 en anglais).
 Une codelette est une fonction écrite en C99 qui réalise l'implémentation
 d'une tâche.
 Une même tâche peut avoir plusieurs implémentations, donc plusieurs codelettes,
 différentes.
 Par exemple, pour une opération de calcul donnée, il est possible de programmer
 plusieurs codelettes avec des optimisations différentes, ainsi qu'une ou
 plusieurs codelettes pour divers type d'accélérateurs (GPU ou Xeon Phi
 par exemple).
 Le fait de pouvoir lancer les codelettes sur plusieurs types de matériel
 justifie le nom de StarPU que l'on peut aussi orthographier *PU: tous les
 types de processeurs (C ou G PU) sont accessibles.
 Une tâche est alors déterminée par ses codelettes ainsi que par la description
 du type d'accès aux données (R, W ou RW).
\end_layout

\begin_layout Standard
Une fois les codelettes et les tâches décrites, le programmeur n'a plus
 qu'à décrire son algorithme de manière séquentielle en soumettant les tâches
 à StarPU dans un ordre qui produirait le résultat correct.
 StarPU se charge alors de distribuer les calculs sur les processeurs et
 les accélérateurs disponibles sur le noeud de calcul.
 En fonction des dépendances, les tâches peuvent être réorganisées et exécutées
 en parallèle si possible.
 Par ailleurs StarPU dispose de plusieurs stratégies d'ordonnancement (
\begin_inset Quotes eld
\end_inset

scheduling
\begin_inset Quotes erd
\end_inset

) qui permettent de tenir compte des efficacités relatives de codelettes,
 des vitesses de transfert mémoire entre les accélérateurs, etc.
 afin d'offrir la meilleure exploitation possible des ressources de calcul.
 
\end_layout

\begin_layout Subsection
MPI
\end_layout

\begin_layout Standard
StarPU est efficace pour répartir les tâches sur un noeud de calcul d'un
 supercalculateur.
 Typiquement, un tel noeud est aujourd'hui constitué d'un ou plusieurs CPU
 multicoeur et, de plus en plus souvent, d'un ou plusieurs accélérateurs
 de type GPU.
 Pour les communications entre noeuds, StarPU utilise l'environnement MPI
 (
\begin_inset Quotes eld
\end_inset

Message Passing Interface
\begin_inset Quotes erd
\end_inset

).
 Pour l'instant, StarPU n'est pas capable de distribuer les tâches entre
 les noeuds MPI.
 En revanche, il est capable de générer automatiquement les tâches de communicat
ions nécessaires au déroulement correct du graphe des tâches.
 Pour cela, l'utilisateur doit établir une distribution initiale des données
 et concevoir un logiciel dans lequel chaque noeud MPI possède une copie
 du graphe des tâches.
 Chaque noeud MPI doit alors (formellement) lancer toutes les tâches du
 graphe.
 Même si tous le graphe est parcouru, la perte d'efficacité est faible car
 seules les tâches pour lesquelles les données sont disponibles seront effective
ment réalisées.
 Si une tâche a besoin d'accéder en lecture à des données d'un noeud MPI
 voisin, StarPU génère automatiquement les dépendances et les transferts
 nécessaires.
\end_layout

\begin_layout Subsection
OpenCL
\end_layout

\begin_layout Standard
SCHNAPS est une bibliothèque, écrite en C, qui permet de résoudre numériquement
 un système de lois de conservation générique par la méthode GD sur un calculate
ur disposant d'un ou plusieurs accélérateurs de type GPU ou CPU multicoeur.
 Afin d'écrire les codelettes spécifiques pour le GPU, nous avons choisi
 l'environnement OpenCL.
 OpenCL permet d'écrire et d'exécuter en parallèle des programmes (appelés
 
\shape italic
kernels
\shape default
) sur tous les processeurs d'un accélérateur.
\end_layout

\begin_layout Standard
Une particularité d'OpenCL est qu'une partie du code est compilée à l'exécution.
 Cette particularité s'explique par la nécessité d'être compatible avec
 des accélérateurs d'architectures matérielles différentes.
\end_layout

\begin_layout Standard
SCHNAPS intègre donc un mécanisme afin de partager du code source de fonction
 avec OpenCL.
 Lorsqu'une portion de code source de SCHNAPS est inclus entre deux balises
 #pragma start_opencl ...
 #pragma end_opencl, cette portion de code sera également compilée une deuxième
 fois à l'exécution pour des appels OpenCL.
 Les fonctions SCHNAPS se comportent donc comme des fonctions C traditionnelles,
 mais elles peuvent être appelées indifféremment depuis le programme hôte
 ou depuis un kernel OpenCL.
\end_layout

\begin_layout Standard
Par ailleurs, pour calculer sur des accélérateurs de type GPU, il est nécessaire
 de dupliquer des données entre le CPU et le GPU.
 Ces copies mémoire sont coûteuses et doivent être traitées avec précaution
 pour éviter notamment les conflits d'accès.
 Auparavant nous gérions ces transferts nous-mêmes grâces au mécanisme des
 évènements (
\begin_inset Quotes eld
\end_inset

events
\begin_inset Quotes erd
\end_inset

) OpenCL.
 Grâce aux évènements, OpenCL permet également l'implémentation d'un graphe
 des tâches et de ses dépendances.
 Cependant il faut décrire 
\begin_inset Quotes eld
\end_inset

à la main
\begin_inset Quotes erd
\end_inset

 les dépendance et il n'y a pas de mécanisme automatique pour les inférer
 à partir de l'accès aux données.
 Depuis l'intégration de StarPU à SCHNAPS nous avons donc préféré déléguer
 cette gestion au support d'exécution.
 
\end_layout

\begin_layout Subsection
Modèles physiques
\end_layout

\begin_layout Standard
Dans SCHNAPS, nous utilisons une notion de 
\shape italic
modèle physique
\shape default
 générique.
 Un modèle dans SCHNAPS (
\family typewriter
Model
\family default
) contient les informations suivantes:
\end_layout

\begin_layout Itemize
dimension 
\begin_inset Formula $m$
\end_inset

 du vecteur 
\begin_inset Formula $W$
\end_inset

 des variables conservatives du système (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:slc"

\end_inset

),
\end_layout

\begin_layout Itemize
flux numérique,
\end_layout

\begin_layout Itemize
condition initiale,
\end_layout

\begin_layout Itemize
flux ou conditions aux limites,
\end_layout

\begin_layout Itemize
termes sources,
\end_layout

\begin_layout Itemize
et éventuellement: solution de référence (si elle existe), caractéristiques
 des matériaux, 
\shape italic
etc.
\end_layout

\begin_layout Standard
Toutes ces informations sont données dans des fonctions SCHNAPS (entourées
 des balises balises #pragma start_opencl ...
 #pragma end_opencl), car elles doivent pouvoir être appelées depuis les
 kernels OpenCL.
\end_layout

\begin_layout Subsection
Sous-domaines
\end_layout

\begin_layout Standard
Afin d'atteindre de bonnes performances en calcul parallèle, SCHNAPS repose
 sur plusieurs niveaux de parallélisme.
 Le premier niveau correspond à celui des sous-domaines.
 C'est un parallélisme à gros grain.
 Les transferts entre sous-domaines sont réalisés grâce à la bibliothèque
 MPI par StarPU.
\end_layout

\begin_layout Standard
Un niveau intermédiaire de parallélisme est piloté par StarPU qui distribue
 les tâches de calcul sur les accélérateurs du noeud MPI.
 Enfin, un troisième niveau de parallélisme à grain fin est piloté au niveau
 des accélérateurs OpenCL.
\end_layout

\begin_layout Standard
Les maillages de SCHNAPS sont organisés pour suivre cette hiérarchie.
 D'abord, le domaine 
\begin_inset Formula $\Omega$
\end_inset

 est découpé en 
\shape italic
sous-domaines
\shape default
.
 Chaque sous-domaine est associé à un noeud MPI.
 Un noeud MPI ne possède que les données de son sous-domaine.
 Mais il dispose aussi d'informations minimales sur le reste du maillage
 afin de pouvoir construire le graphe des tâches StarPU du calcul global.
 
\end_layout

\begin_layout Standard
S'il n'y a qu'un seul sous-domaine, SCHNAPS peut fonctionner sans la bibliothèqu
e MPI.
\end_layout

\begin_layout Subsection
Macrocellules et champs
\end_layout

\begin_layout Standard
Par ailleurs, chaque sous-domaine est lui-même découpé en macrocellules.
 Les macrocellules sont obtenus grâce à un diffémorphisme (transformation
 géométrique) qui envoie le cube de référence 
\begin_inset Formula $[0,1]^{3}$
\end_inset

 sur un hexaèdre courbé.
 Il est possible d'envisager des transformation trilinéaires: hexaèdre à
 8 noeud de type H8 dans la terminologie élément fini; ou des transformations
 quadratiques: hexaèdre à 20 noeud de type H20.
\end_layout

\begin_layout Standard
Les macro-cellules sont ensuite subdivisées dans chaque directions en sous-cellu
les partageant les mêmes caractéristiques (modélisation physique, interpolation).
 Notons que dans chaque macrocellule, les sous-cellules sont organisées
 suivant une grille courbe mais régulière et que les données géométriques
 de type H8 ou H20 sont partagées entre toutes les sous-cellules.
 Cette organisation a deux avantages.
 Elle permet d'abord de manipuler des structures de données géométriques
 légères car seul un maillage grossier est nécessaire.
 C'est ce maillage grossier (macro-maillage), qui est partagé entre les
 noeuds MPI et qui permet de construire le graphe des tâches StarPU.
 D'autre part, l'organisation régulière des sous-cellules permet d'envisager
 des optimisations très efficaces notamment dans les calculs sur GPU.
 Les paramètres de découpage sont en général décrit dans deux tableaux deg[0:2]
 et raf[0:2].
 deg[i] représente le degré d'interpolation dans la direction du maillage
 logique i et raf[i] le nombre de sous-cellules dans cette direction.
 Dans la direction i il y a donc (deg[i]+1)*raf[i] points d'interpolation.
 Il est possible d'avoir des paramètres de discrétisation différents suivant
 chaque direction, ce qui permet par exemple de réaliser des calculs 1D
 ou 2D, même si la structure du maillage est toujours 3D.
\end_layout

\begin_layout Standard
A chaque macro-cellule du macro-maillage est associé un champ.
 Cette structure contient les valeurs des variables conservatives sur les
 points d'interpolation à l'intérieur des sous-cellules.
\end_layout

\begin_layout Standard
Les échanges de données entre macrocellules et le calcul des conditions
 aux limites sont assurés par une structure d'interface.
 Cette structure est en particulier chargée d'extraire les données de bord
 des macrocellules dans des tampons.
 Ces tampons sont très utiles pour optimiser les dépendances de données
 et offrir plus de liberté à StarPU pour optimiser le parcours du graphe
 des tâches
\end_layout

\begin_layout Standard
Nous réalisons les calculs sur les champ des macrocellules à partir de codelette
s StarPU.
 Ces codelettes calculent les flux, les termes sources dans les macrocellules.
 Les codelettes calculent également les flux provenant des interfaces.
 Ils réalisent enfin les extractions de données volumiques vers les interfaces.
 Nous avons écrit à chaque fois deux versions des codelettes: une version
 C pour CPU et une version OpenCL qui peut s'exécuter sur un CPU multicoeur
 ou un GPU.
 
\end_layout

\begin_layout Subsection
Simulation
\end_layout

\begin_layout Standard
Une 
\shape italic
simulation
\shape default
 est une collection de champs sur des macrocellules.
 Cette classe est conçue pour contenir les algorithmes à appliquer sur les
 macrocellules.
 En particulier, c'est cette classe qui lance les tâches StarPU.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename exemple-task.png
	width 12cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Graphe-des-tâches"

\end_inset

Graphe des tâches pour un calcul dans un sous-domaine contenant 3 zones.
 Les tâches sont représentées par les noeuds du graphe et les flèches représente
nt les dépendances entre les tâches (une tâche doit attendre la fin des
 tâches dont elle dépend avant de démarrer).
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Éléments géométriques
\begin_inset CommandInset label
LatexCommand label
name "subsec:elem_geom"

\end_inset


\end_layout

\begin_layout Standard
Dans cette section, nous nous plaçons au niveau d'un élément 
\begin_inset Formula $L$
\end_inset

.
 Suivant la zone dans laquelle il se trouve, cet élément peut avoir des
 caractéristiques géométriques différentes.
 Nous utilisons le formalisme classique des éléments finis.
 À chaque zone nous attribuons un élément de référence 
\begin_inset Formula $\hat{L}$
\end_inset

.
 Cet élément s'appuie sur des 
\shape slanted
noeuds géométriques
\shape default
, notés 
\begin_inset Formula $\hat{X}_{i}$
\end_inset

 et des 
\shape slanted
fonctions de base géométriques
\shape default
, notées 
\begin_inset Formula $\hat{\psi}_{i}$
\end_inset

 telles que
\begin_inset Formula 
\[
\hat{\psi}_{i}(\hat{X}_{j})=\delta_{ij}.
\]

\end_inset

Dans SCHNAPS, dans une zone donnée, le nombre de noeuds et de fonctions
 géométriques est noté 
\family typewriter
nb_nodes
\family default
.
 Pour un hexaèdre à huit noeuds (élément de type H8), 
\family typewriter
nb_nodes
\family default
=8.
 Les noeuds sont donnés dans le tableau 
\family typewriter
ref_node
\family default
.
 L'élément de référence possède également un certain nombre de faces, noté
 
\family typewriter
nb_faces
\family default
.
 Le tableau 
\family typewriter
face2node
\family default
 permet de retrouver les noeuds d'une face donnée.
 Le numéro du j-ième noeud de la face jf est donné par 
\family typewriter
face2node[nb_face_nodes*jf+j]
\family default
.
 L'entier 
\family typewriter
nb_face_nodes
\family default
 est le nombre maximal de noeuds par face (par exemple 
\family typewriter
nb_face_nodes
\family default
=4 pour un hexaèdre à 8 noeuds).
\end_layout

\begin_layout Standard
Nous utiliserons ce formalisme pour toutes les familles d'éléments finis
 de SCHNAPS, qu'il s'agisse d'hexaèdres H8 ou H20.
 A l'avenir nous envisageons de traiter également des tétraèdres ou d'autres
 éléments courbes.
\end_layout

\begin_layout Standard
À titre d'exemple, nous montrons maintenant précisément comment nous pouvons
 définir l'interpolation pour des hexaèdres à 8 noeuds (éléments de type
 H8 dans la terminologie classique des éléments finis).
 En général, dans SCHNAPS nous utilisons des éléments quadratiques de type
 H20, mais la description du H8 est plus simple.
 Dans ce cas, l'élément de référence 
\begin_inset Formula $\hat{L}$
\end_inset

 est le cube unité
\begin_inset Formula 
\[
\hat{L}=[0,1]^{3}.
\]

\end_inset

Soient 
\begin_inset Formula $\hat{X}=(\hat{x},\hat{y},\hat{z})$
\end_inset

 les coordonnées dans l'élément de référence.
 Les noeuds de référence 
\begin_inset Formula $\hat{X}^{i}$
\end_inset

, 
\begin_inset Formula $i=1\cdots8$
\end_inset

 et les fonctions géométriques 
\begin_inset Formula $\hat{\psi}_{i}$
\end_inset

 de l'élément de référence sont données par
\begin_inset Formula 
\[
\begin{array}{ccc}
i & \hat{X}^{i} & \hat{\psi}_{i}\\
1 & (0,0,0) & (1-\hat{x})(1-\hat{y})(1-\hat{z})\\
2 & (1,0,0) & \hat{x}(1-\hat{y})(1-\hat{z})\\
3 & (1,1,0) & \hat{x}\hat{y}(1-\hat{z})\\
4 & (0,1,0) & (1-\hat{x})\hat{y}(1-\hat{z})\\
5 & (0,0,1) & (1-\hat{x})(1-\hat{y})\hat{z}\\
6 & (1,0,1) & \hat{x}(1-\hat{y})\hat{z}\\
7 & (1,1,1) & \hat{x}\hat{y}\hat{z}\\
8 & (0,1,1) & (1-\hat{x})\hat{y}\hat{z}
\end{array}
\]

\end_inset

Un hexaèdre H8 arbitraire est alors défini par huit noeuds 
\begin_inset Formula $X_{L}^{i}$
\end_inset

.
 La transformation géométrique qui envoie 
\begin_inset Formula $\hat{L}$
\end_inset

 sur 
\begin_inset Formula $L$
\end_inset

 est définie par
\begin_inset Formula 
\[
\tau_{L}(\hat{X})=\hat{\psi}_{i}(\hat{X})X_{L}^{i}.
\]

\end_inset

Nous faisons l'hypothèse que les noeuds 
\begin_inset Formula $X_{L}^{i}$
\end_inset

 sont choisis de telle sorte que 
\begin_inset Formula $\tau_{L}$
\end_inset

 est une transformation directe et inversible.
 En pratique, il faut s'assurer que le choix des noeuds ne conduit pas à
 des éléments mal orientés ou trop déformés.
 Comme les fonctions de base géométriques satisfont 
\begin_inset Formula 
\[
\hat{\psi}_{i}(\hat{X}^{j})=\delta_{ij}
\]

\end_inset

nous déduisons que la transformation géométrique envoie les noeuds de référence
 sur les noeuds de l'élément 
\begin_inset Formula $L$
\end_inset


\begin_inset Formula 
\[
\tau_{L}(\hat{X}^{i})=X_{L}^{i}.
\]

\end_inset


\end_layout

\begin_layout Standard
Pour la numérotation des faces, nous utilisons la convention suivante.
 Tout d'abord, pour le cube de référence, les faces sont numérotées de 0
 à 5 selon le modèle de la figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cube_ref"

\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=5] 
\end_layout

\begin_layout Plain Layout

% face avant
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0,0,1)--(1,0,1)--(1,1,1)--(0,1,1)--cycle;
\end_layout

\begin_layout Plain Layout

% face dessus
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0,1.2,1)--(1,1.2,1)--(1,1.2,0)--(0,1.2,0)--cycle; 
\end_layout

\begin_layout Plain Layout

% face droite
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (1.1,0,0)--(1.1,1,0)--(1.1,1,1)--(1.1,0,1)--cycle; 
\end_layout

\begin_layout Plain Layout

% face arrière
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (0,0,0)--(1,0,0)--(1,1,0)--(0,1,0)--cycle; % face complète
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0.61,0,0)--(0.72,0,0); 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (1,0.9,0)--(1,1,0)--(.8,1,0); 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0,.82,0)--(0,0.6,0); 
\end_layout

\begin_layout Plain Layout

% face dessous
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (0,-.2,1)--(1,-.2,1)--(1,-.2,0)--(0,-.2,0)--cycle; % face complète
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0,-.2,0.5)--(0,-.2,1)--(1,-.2,1)--(1,-.2,0)--(.9,-.2,0);
 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (.72,-.2,0)--(0.61,-.2,0);
\end_layout

\begin_layout Plain Layout

% face gauche
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (-.1,0,0)--(-.1,1,0)--(-.1,1,1)--(-.1,0,1)--cycle; 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (-.1,.82,0)--(-.1,0.6,0); 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (-.1,0,0.75)--(-.1,0,1)--(-.1,1,1)--(-.1,1,.5); 
\end_layout

\begin_layout Plain Layout

% arêtes horizontales, de l'arrière vers l'avant 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw (0,0,0) -- (0,0,1); % bas gauche 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw (1,0,0) -- (1,0,1); % bas droit 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw (1,1,0) -- (1,1,1); % haut droit 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw (0,1,0) -- (0,1,1); % haut gauche
\end_layout

\begin_layout Plain Layout

%
\backslash
draw[xshift=-2pt] (1,0) node[below] {a/b}; 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw[line width=1pt,color=red,domaine={1.25}{1.5},samples=100,dotted] plot
 (
\backslash
x,1-
\backslash
x); 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Cube de référence.
\begin_inset CommandInset label
LatexCommand label
name "fig:cube_ref"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Cube de références, n° des faces, un point de GL
\end_layout

\end_inset

Nous définissons ensuite un tableau de permutation des axes des faces
\begin_inset Formula 
\[
\mathrm{axis\_permut}=\left(\begin{array}{cccc}
0 & 2 & 1 & 0\\
1 & 2 & 0 & 1\\
2 & 0 & 1 & 1\\
2 & 1 & 0 & 0\\
0 & 1 & 2 & 1\\
1 & 0 & 2 & 0
\end{array}\right).
\]

\end_inset

Chaque ligne correspond à une face du cube.
 Les trois premières colonnes code une permutation des axes selon la convention
 
\begin_inset Formula $"0"$
\end_inset

 pour 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $"1"$
\end_inset

 pour 
\begin_inset Formula $y$
\end_inset

 et 
\begin_inset Formula $"2"$
\end_inset

 pour 
\begin_inset Formula $z$
\end_inset

, les deux premiers axes étant dans le plan de la face et le troisième orienté
 suivant la normale sortante.
 La dernière colonne donne la valeur de la troisième coordonnée qui est
 constante sur la face.
 Par exemple, la troisième ligne correspond à la face 2 qui est dans le
 plan 
\begin_inset Formula $("2","0")=(z,x).$
\end_inset

 La direction normale à la face est la direction 
\begin_inset Formula $"1"=y$
\end_inset

.
 Enfin sur cette face, on a bien 
\begin_inset Formula $y=1$
\end_inset

.
 
\end_layout

\begin_layout Standard
Pour un numéro de face 
\begin_inset Formula $\texttt{ifa}$
\end_inset

, nous notons 
\begin_inset Formula $\text{opposite\_face}(\texttt{ifa})$
\end_inset

 le numéro de face opposée:
\begin_inset Formula 
\[
\text{opposite\_face}=\left(\begin{array}{c}
2\\
3\\
0\\
1\\
5\\
4
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
La géométrie des éléments est décrite dans la struture geometry.
 Cette classe contient des fonctions SCHNAPS (qui pourront donc être appelées
 depuis les kernel OpenCL) pour calculer la transformation géométrique 
\begin_inset Formula $\tau$
\end_inset

 en un point de référence, son gradient, son jacobien, son inverse, le vecteur
 normal dans le cas d'un élément surfacique, 
\shape italic
etc
\shape default
.
 
\end_layout

\begin_layout Subsection
Interpolation
\end_layout

\begin_layout Standard
Une fois définie la géométrie d'un élément, on peut définir l'interpolation
 d'un champ scalaire.
 Cette information est décrite dans la struture 
\family typewriter
interpolation
\family default
.
\end_layout

\begin_layout Standard
Pour l'instant dans SCHNAPS, pour des raisons d'efficacité, nous utilisons
 une approximation nodale adaptée à la quadrature numérique (voir 
\begin_inset CommandInset citation
LatexCommand cite
key "cohen2006spatial,klockner2009nodal"

\end_inset

): les champs sont définis aux points d'intégration de Gauss-Lobatto des
 éléments.
 Ce choix permet d'accéder directement aux champs pour l'intégration numérique
 dans le volume et sur les faces.
 Ce choix assure aussi que les matrices masses locales sont diagonales.
\end_layout

\begin_layout Standard
Pour commencer, nous décrivons par exemple comment nous interpolons les
 champs sur un élément de type H8 avec des polynômes de degré 
\begin_inset Formula $d$
\end_inset

.
 Pour simplifier, nous considérons d'abord le cas où la macrocellule corresponda
nte ne contient qu'une seule sous-cellules.
 C'est à dire nous supposons que raf[0]=raf[1]=raf[2]=1 dans les trois direction
s.
\end_layout

\begin_layout Standard
Pour l'interpolation nous fixons d'abord dans la cellule 
\begin_inset Formula $L$
\end_inset

 un degré 
\begin_inset Formula $d$
\end_inset

.
 Nous considérons les 
\begin_inset Formula $(d+1)$
\end_inset

 points de Gauss-Lobatto 
\begin_inset Formula $(\xi_{i})_{i=0\cdots d}$
\end_inset

 sur 
\begin_inset Formula $[0,1],$
\end_inset

 et les poids d'intégration correspondants 
\begin_inset Formula $\omega_{i}$
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=5] 
\end_layout

\begin_layout Plain Layout

% face avant
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0,0,1)--(1,0,1)--(1,1,1)--(0,1,1)--cycle;
\end_layout

\begin_layout Plain Layout

% face dessus
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0,1.2,1)--(1,1.2,1)--(1,1.2,0)--(0,1.2,0)--cycle; 
\end_layout

\begin_layout Plain Layout

% face droite
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (1.1,0,0)--(1.1,1,0)--(1.1,1,1)--(1.1,0,1)--cycle; 
\end_layout

\begin_layout Plain Layout

% face arrière
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (0,0,0)--(1,0,0)--(1,1,0)--(0,1,0)--cycle; % face complète
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0.61,0,0)--(0.72,0,0); 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (1,0.9,0)--(1,1,0)--(.8,1,0); 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0,.82,0)--(0,0.6,0); 
\end_layout

\begin_layout Plain Layout

% face dessous
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (0,-.2,1)--(1,-.2,1)--(1,-.2,0)--(0,-.2,0)--cycle; % face complète
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (0,-.2,0.5)--(0,-.2,1)--(1,-.2,1)--(1,-.2,0)--(.9,-.2,0);
 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (.72,-.2,0)--(0.61,-.2,0);
\end_layout

\begin_layout Plain Layout

% face gauche
\end_layout

\begin_layout Plain Layout


\backslash
draw[dashed] (-.1,0,0)--(-.1,1,0)--(-.1,1,1)--(-.1,0,1)--cycle; 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (-.1,.82,0)--(-.1,0.6,0); 
\end_layout

\begin_layout Plain Layout


\backslash
draw[line width=.9pt] (-.1,0,0.75)--(-.1,0,1)--(-.1,1,1)--(-.1,1,.5); 
\end_layout

\begin_layout Plain Layout

% arêtes horizontales, de l'arrière vers l'avant 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw (0,0,0) -- (0,0,1); % bas gauche 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw (1,0,0) -- (1,0,1); % bas droit 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw (1,1,0) -- (1,1,1); % haut droit 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw (0,1,0) -- (0,1,1); % haut gauche
\end_layout

\begin_layout Plain Layout

%
\backslash
draw[xshift=-2pt] (1,0) node[below] {a/b}; 
\end_layout

\begin_layout Plain Layout

%
\backslash
draw[line width=1pt,color=red,domaine={1.25}{1.5},samples=100,dotted] plot
 (
\backslash
x,1-
\backslash
x); 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Cube de référence.
\begin_inset CommandInset label
LatexCommand label
name "fig:cube_ref-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

.
 Nous notons aussi 
\begin_inset Formula $I_{k}$
\end_inset

 le 
\begin_inset Formula $k^{\text{ième}}$
\end_inset

 polynôme de Lagrange associé aux points 
\begin_inset Formula $\xi_{i}$
\end_inset

.
 Rappelons que 
\begin_inset Formula $I_{k}$
\end_inset

 est un polynôme de degré 
\begin_inset Formula $d$
\end_inset

 et que
\begin_inset Formula 
\[
I_{j}(\xi_{i})=\delta_{ij}.
\]

\end_inset

Nous construisons alors, sur l'élément de référence 
\begin_inset Formula $\hat{L}$
\end_inset

, les points de Gauss 
\begin_inset Formula $\hat{Y}_{q}$
\end_inset

, les poids 
\begin_inset Formula $\hat{\lambda}_{q}$
\end_inset

 et les fonctions d'interpolation 
\begin_inset Formula $\hat{\varphi}^{q}(\hat{X})$
\end_inset

 à partir de produits tensoriels de quantités monodimensionnelles.
 Plus précisément, soient 
\begin_inset Formula $i$
\end_inset

, 
\begin_inset Formula $j$
\end_inset

 et 
\begin_inset Formula $k$
\end_inset

 trois entiers dans 
\begin_inset Formula $\{0\cdots d\}$
\end_inset

 et soit 
\begin_inset Formula $q=(d+1)^{2}k+(d+1)j+i$
\end_inset

 alors
\begin_inset Formula 
\[
\hat{Y}_{q}=(\xi_{i},\xi_{j},\xi_{k}),\quad\hat{\lambda}_{q}=\omega_{i}\omega_{j}\omega_{k},\quad\hat{\varphi}^{q}(\hat{X})=I_{i}(\hat{x})I_{j}(\hat{y})I_{k}(\hat{z}).
\]

\end_inset

Finalement, nous obtenons les fonctions de base sur l'élément 
\begin_inset Formula $L$
\end_inset

 en transportant les fonctions d'interpolation de référence avec la transformati
on géométrique.
\begin_inset Formula 
\[
\varphi_{L}^{i}(X)=\hat{\varphi}^{i}(\hat{X})\text{ with }X=\tau_{L}(\hat{X}).
\]

\end_inset


\end_layout

\begin_layout Standard
La classe 
\family typewriter
interpolation
\family default
 contient des fonctions permettant de calculer: la position des points de
 Gauss du volume ou des faces, les poids de Gauss, les valeurs des fonctions
 de base et de leurs gradients.
\end_layout

\begin_layout Subsection
Interpolation de Gauss-Lobatto avec des sous-cellules
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Pour l'instant dans SCHNAPS, pour des raisons d'efficacité, nous utilisons
 une approximation nodale adaptée à la quadrature numérique (voir 
\begin_inset CommandInset citation
LatexCommand cite
key "CFP06,KWBH09"

\end_inset

): les champs sont définis aux points d'intégration de Gauss des éléments.
 Ce choix permet d'accéder directement aux champs pour l'intégration numérique
 dans le volume.
 Ce choix assure aussi que les matrices masses locales sont diagonales.
\end_layout

\begin_layout Plain Layout
Nous décrivons par exemple comment nous interpolons les champs sur un élément
 de type H8 avec des polynômes de degré 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\end_inset

En fait, chaque macrocellule peut-être découpée en plusieurs sous-cellules.
 Pour l'interpolation nous fixons d'abord dans la macrocellule 
\begin_inset Formula $L$
\end_inset

 un degré 
\begin_inset Formula $d(\ell)$
\end_inset

 pour chaque direction 
\begin_inset Formula $\ell=0,1,2$
\end_inset

.
 Dans chaque direction, nous considérons les 
\begin_inset Formula $(d(\ell)+1)$
\end_inset

 points de Gauss-Lobatto 
\begin_inset Formula $(\xi_{i})_{i=0\cdots d(\ell)}$
\end_inset

 sur 
\begin_inset Formula $[0,1],$
\end_inset

 et les poids d'intégration correspondants 
\begin_inset Formula $\omega_{i}$
\end_inset

.
 Nous considérons de plus un raffinement 
\begin_inset Formula $\nraf(\ell)$
\end_inset

 pour 
\begin_inset Formula $\ell=0,1,2$
\end_inset

.
 Nous notons aussi 
\begin_inset Formula $I_{k}$
\end_inset

 le 
\begin_inset Formula $k^{\text{ième}}$
\end_inset

 polynôme de Lagrange associé aux points 
\begin_inset Formula $\xi_{i}$
\end_inset

.
 Rappelons que 
\begin_inset Formula $I_{k}$
\end_inset

 est un polynôme de degré 
\begin_inset Formula $d$
\end_inset

 et que
\begin_inset Formula 
\[
I_{j}(\xi_{i})=\delta_{ij}.
\]

\end_inset

Sur l'élément de référence 
\begin_inset Formula $\hat{L}$
\end_inset

, nous construisons alors les points de Gauss-Lobatto 
\begin_inset Formula $\hat{Y}_{q}$
\end_inset

, les poids 
\begin_inset Formula $\hat{\lambda}_{q}$
\end_inset

 et les fonctions d'interpolation 
\begin_inset Formula $\hat{\varphi}^{q}(\hat{X})$
\end_inset

 à partir de produits tensoriels de quantités monodimensionnelles.
 Plus précisément, soient 
\begin_inset Formula $i(\ell)_{\ell=0,1,2}$
\end_inset

 trois entiers dans 
\begin_inset Formula $\{0\cdots d(0)\}\times\{0\cdots d(1)\}\times\{0\cdots d(2)\}$
\end_inset

 et 
\begin_inset Formula $r(\ell)_{\ell=0,1,2}$
\end_inset

 trois entiers dans 
\begin_inset Formula $\{0\cdots\nraf(0)\}\times\{0\cdots\nraf(1)\}\times\{0\cdots\nraf(2)\}$
\end_inset

 et soit 
\begin_inset Formula 
\begin{eqnarray*}
q & = & i(0)\\
 & + & i(1)(d(0)+1)\\
 & + & i(2)(d(0)+1)(d(1)+1)\\
 & + & r(0)(d(0)+1)(d(1)+1)(d(2)+1)\\
 & + & r(1)(d(0)+1)(d(1)+1)(d(2)+1)\nraf(0)\\
 & + & r(2)(d(0)+1)(d(1)+1)(d(2)+1)\nraf(0)\nraf(1),
\end{eqnarray*}

\end_inset

alors
\begin_inset Formula 
\begin{eqnarray*}
\hat{Y}_{q} & = & (h(0)(r(0)+\xi_{i(0)}),h(1)(r(1)+\xi_{i(1)}),h(2)(r(2)+\xi_{i(2)})),\\
\hat{\lambda}_{q} & = & h(0)\omega_{i(0)}h(1)\omega_{i(1)}h(2)\omega_{i(2)},\\
\hat{\varphi}^{q}(\hat{X}) & = & I_{i(0)}(\frac{\hat{x}}{h(0)}-r(0))I_{i(1)}(\frac{\hat{y}}{h(1)}-r(1))I_{i(2)}(\frac{\hat{z}}{h(2)}-r(2))\,\chi^{r}(\hat{X}),
\end{eqnarray*}

\end_inset

où 
\begin_inset Formula $h(\ell)=1/\nraf(\ell)$
\end_inset

 et
\begin_inset Formula 
\[
\chi^{r}(\hat{X})=\mathbb{1}_{[h(0)r(0),h(0)(r(0)+1)]}(\hat{x})\mathbb{1}_{[h(1)r(1),h(1)(r(1)+1)]}(\hat{y})\mathbb{1}_{[h(2)r(2),h(2)(r(2)+1)]}(\hat{z}).
\]

\end_inset

En pratique, on calcule 
\begin_inset Formula $q$
\end_inset

 grâce à la formule de Hörner
\begin_inset Formula 
\[
q=i(0)+(d(0)+1)(i(1)+(d(1)+1)(i(2)+(d(2)+1)(r(0)+\nraf(0)(r(1)+\nraf(1)r(2)))).
\]

\end_inset

Dans la suite nous utiliserons la notation 
\begin_inset Formula $q$
\end_inset

 aussi pour le multi-indice 
\begin_inset Formula $q=(i(0),i(1),i(2),r(0),r(1),r(2))=(i,r)$
\end_inset

.
\end_layout

\begin_layout Standard
Finalement, nous obtenons les fonctions de base sur l'élément 
\begin_inset Formula $L$
\end_inset

 en transportant les fonctions d'interpolation de référence avec la transformati
on géométrique.
\begin_inset Formula 
\[
\varphi_{L}^{i}(X)=\hat{\varphi}^{i}(\hat{X})\text{ with }X=\tau_{L}(\hat{X}).
\]

\end_inset

Nous définissons à présent l'indexation des points de Gauss-Lobatto sur
 les faces.
 Ces points sont repérés par un numéro de face 
\begin_inset Formula $\texttt{ifa}\in\{0\cdots5\}$
\end_inset

, deux indices de points 
\begin_inset Formula $(i'(0),i'(1))$
\end_inset

 et deux indices de sous-face 
\begin_inset Formula $(r'(0),r'(1))$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
exemple de point GL
\end_layout

\end_inset

 Nous utilisons le tableau 
\begin_inset Formula $\mathrm{axis\_permut}$
\end_inset

 introduit à la section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:elem_geom"

\end_inset

 pour retrouver la position du point de Gauss-Lobatto dans le volume à l'aide
 des formules suivantes
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left\{ \begin{array}{lcl}
i(\mathrm{axis\_permut}(\texttt{ifa},0)) & = & i'(0),\\
i(\mathrm{axis\_permut}(\texttt{ifa},1)) & = & i'(1),\\
i(\mathrm{axis\_permut}(\texttt{ifa},2)) & = & \mathrm{axis\_permut}(\texttt{ifa},3)\,d(\mathrm{axis\_permut}(\texttt{ifa},3)).
\end{array}\right.
\]

\end_inset

Les indices de la sous-cellule sont donnés par
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left\{ \begin{array}{lcl}
r(\mathrm{axis\_permut}(\texttt{ifa},0)) & = & r'(0),\\
r(\mathrm{axis\_permut}(\texttt{ifa},1)) & = & r'(1),\\
r(\mathrm{axis\_permut}(\texttt{ifa},2)) & = & \mathrm{axis\_permut}(\texttt{ifa},3)\,(\nraf(\mathrm{axis\_permut}(\texttt{ifa},3))-1).
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Standard
Les degrés d'approximation permutés sont donnés par 
\begin_inset Formula $d'(\mathrm{axis\_permut}(\texttt{ifa},\ell))=d(\ell)$
\end_inset

 et les raffinements permutés sont donnés par 
\begin_inset Formula $\nraf'(\mathrm{axis\_permut}(\texttt{ifa},\ell))=\nraf(\ell)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Dans la suite, il est nécessaire de pouvoir passer de l'indexation des points
 de Gauss-Lobatto sur les faces à leur indexation dans les volumes.
 Avec la convention choisie, le numéro 
\begin_inset Formula $q'=(i',r')$
\end_inset

 du point de Gauss-Lobatto sur la face est donné par 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
q' & = & i'(0)\\
 & + & i'(1)(d'(0)+1)\\
 & + & r'(0)(d'(0)+1)(d'(1)+1)\\
 & + & r'(1)(d'(0)+1)(d'(1)+1)\nraf'(0).
\end{eqnarray*}

\end_inset

Nous notons 
\begin_inset Formula $\Pi$
\end_inset

 la transformation qui fait passer de la numérotation 
\begin_inset Formula $q'$
\end_inset

 sur le bord 
\begin_inset Formula $\partial L$
\end_inset

 à la numérotation 
\begin_inset Formula $q$
\end_inset

 à l'intérieur de la cellule
\begin_inset Formula 
\[
q=\Pi(\texttt{ifa},q').
\]

\end_inset


\end_layout

\begin_layout Standard
Enfin, nous avons aussi besoin d'une numérotation des points de Gauss des
 faces des sous-cellules.
 Soit un numéro de sous-cellule 
\begin_inset Formula $r$
\end_inset

, un numéro de face 
\begin_inset Formula $\texttt{ifa}$
\end_inset

 et un numéro de point de Gauss de sous-cellule 
\begin_inset Formula $i'$
\end_inset

.
 L'indice correspondant à 
\begin_inset Formula $q$
\end_inset

 dans la cellule 
\begin_inset Formula $L$
\end_inset

 est donné par la transformation
\begin_inset Formula 
\[
q=\pi(r,\texttt{ifa},i').
\]

\end_inset

Dans le détail, on a 
\begin_inset Formula $q=(i(0),i(1),i(2),r(0),r(1),r(2))$
\end_inset

 avec
\begin_inset Formula 
\[
\left\{ \begin{array}{lcl}
i(\mathrm{axis\_permut}(\texttt{ifa},0)) & = & i'(0),\\
i(\mathrm{axis\_permut}(\texttt{ifa},1)) & = & i'(1),\\
i(\mathrm{axis\_permut}(\texttt{ifa},2)) & = & \mathrm{axis\_permut}(\texttt{ifa},3)\,d(\mathrm{axis\_permut}(\texttt{ifa},3)).
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Subsection
Schéma GD pour l'interpolation de Gauss-Lobatto sur des sous-cellules
\end_layout

\begin_layout Standard
Dans le cas de l'interpolation de Gauss-Lobatto sur des sous cellules, nous
 pouvons exprimer l'algorithme de calcul GD sous une forme plus efficace,
 direction par direction.
 Nous commençons par remplacer les intégrales de volumes et de bord par
 leurs quadratures de Gauss-Lobatto.
 Pour une cellule 
\begin_inset Formula $L$
\end_inset

 et une composante 
\begin_inset Formula $q=(i,r)$
\end_inset

 la quadrature Gauss-Lobatto s'écrit
\begin_inset Formula 
\[
\omega_{q}^{L}\frac{d}{dt}W_{L}^{q}-\mathcal{V}+\mathcal{D}+\mathcal{B}=\omega_{q}^{L}S(Y_{L}^{q}),
\]

\end_inset

où 
\begin_inset Formula $\mathcal{V}$
\end_inset

, 
\begin_inset Formula $\mathcal{D}$
\end_inset

 et 
\begin_inset Formula $\mathcal{B}$
\end_inset

 désignent respectivement les termes volumiques, les termes aux interfaces
 des sous-cellules et les termes de bord de la cellule 
\begin_inset Formula $L$
\end_inset

.
 Pour l'integrale de volume, il faut considérer les contributions sur tous
 les points de Gauss-Lobatto 
\begin_inset Formula $Y_{L}^{p}$
\end_inset

 avec 
\begin_inset Formula $p=(j(0),j(1),j(2),s(0),s(1),s(2))=(j,s)$
\end_inset

, soit
\begin_inset Formula 
\[
\mathcal{V}=\sum_{p}\omega_{p}^{L}F(W_{L}^{p})\cdot\nabla\varphi_{q}^{L}(Y_{L}^{p}).
\]

\end_inset

D'autre part, si 
\begin_inset Formula $q$
\end_inset

 correspond à un point de Gauss interne à la cellule 
\begin_inset Formula $L$
\end_inset

 on a
\begin_inset Formula 
\[
\mathcal{B}=0.
\]

\end_inset

Si 
\begin_inset Formula $q$
\end_inset

 correspond à un point du bord 
\begin_inset Formula $\partial L$
\end_inset

, il existe au moins un numéro de face 
\begin_inset Formula $\text{ifa}$
\end_inset

 et un indice de bord 
\begin_inset Formula $q'$
\end_inset

 tel que
\begin_inset Formula 
\[
q=\Pi(\text{ifa},q')
\]

\end_inset

et
\begin_inset Formula 
\[
\mathcal{B}=\sum_{q=\Pi(\text{ifa},q')}\omega_{q'}^{\partial L}F(W_{L}^{q},W_{R}(Y_{L}^{q}),n_{LR}(Y_{L}^{q})).
\]

\end_inset

Il reste à expliciter les termes de saut aux interfaces des sous-cellules.
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $q$
\end_inset

 correspond à un point de Gauss interne à une sous-cellule alors
\begin_inset Formula 
\[
\mathcal{D}=0.
\]

\end_inset

Si 
\begin_inset Formula $q$
\end_inset

 correspond à un point de bord de la sous-cellule 
\begin_inset Formula $r$
\end_inset

 alors il existe une ou plusieurs sous-faces 
\begin_inset Formula $\texttt{ifa}$
\end_inset

 et un numéro 
\begin_inset Formula $i'$
\end_inset

 de point de Gauss dans la sous-face tels que
\begin_inset Formula 
\[
q=\pi(r,\texttt{ifa},i').
\]

\end_inset

Le point 
\begin_inset Formula $q$
\end_inset

 admet un unique vis-à-vis 
\begin_inset Formula $\tilde{q}$
\end_inset

 sur la face 
\begin_inset Formula $\texttt{ifa}$
\end_inset

 dans une sous-cellule voisine 
\begin_inset Formula $\tilde{r}$
\end_inset


\begin_inset Formula 
\[
\tilde{q}=\pi(\tilde{r},\text{opposite\_face}(\texttt{ifa}),\tilde{i}'),
\]

\end_inset

et les points de Gauss-Lobatto correspondants sont confondus
\begin_inset Formula 
\[
Y_{L}^{\tilde{q}}=Y_{L}^{q}.
\]

\end_inset

Avec ces notations, les flux d'interfaces internes s'écrivent
\begin_inset Formula 
\[
\mathcal{D}=\sum_{q=\pi(r,\text{ifa},i')}\omega_{i'}^{\partial r}F(W_{L}^{q},W_{L}^{\tilde{q}},n_{r\tilde{r}}(Y_{L}^{q})),
\]

\end_inset

où 
\begin_inset Formula $\omega_{i'}^{\partial r}$
\end_inset

 désigne les poids de Gauss des point 
\begin_inset Formula $i'$
\end_inset

 sur le bord de la sous-cellule 
\begin_inset Formula $r$
\end_inset

.
 La normale à l'interface entre les sous-cellules 
\begin_inset Formula $r$
\end_inset

 et 
\begin_inset Formula $\tilde{r}$
\end_inset

, orientée de 
\begin_inset Formula $r$
\end_inset

 vers 
\begin_inset Formula $\tilde{r}$
\end_inset

 est notée 
\begin_inset Formula $n_{r\tilde{r}}$
\end_inset

.
\end_layout

\begin_layout Subsection
Algorithme GD avec optimisation des accès mémoire sur une macro-cellule
\end_layout

\begin_layout Standard
to do (je m'en occupe)
\end_layout

\begin_layout Section
Programmation de la MHD dans SCHNAPS
\end_layout

\begin_layout Subsection
Commentaires sur la programmation
\end_layout

\begin_layout Standard
Description des fonctions fluxnum, etc.
\end_layout

\begin_layout Subsection
Premières validations
\end_layout

\begin_layout Standard
Validation pseudo 1D.
 Orszag tang 2D périodique
\end_layout

\begin_layout Subsection
Tests de performances
\end_layout

\begin_layout Standard
comparaisons: ordre, StarPU, 2D/3D activation ou désactivation des CPU/GPU
 dans StarPU.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "biblio_chapitre_schnaps"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
